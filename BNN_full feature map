import torch
import torch.nn as nn
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt
import numpy as np

def print_full_matrix(matrix, title="", max_display_rows=28, max_display_cols=28):
    """è¼¸å‡ºå®Œæ•´çŸ©é™£ï¼Œå¯æ§åˆ¶é¡¯ç¤ºçš„è¡Œåˆ—æ•¸"""
    if matrix.ndim != 2:
        print(f"çŸ©é™£å½¢ç‹€: {matrix.shape}")
        return
    
    rows, cols = matrix.shape
    display_rows = min(rows, max_display_rows)
    display_cols = min(cols, max_display_cols)
    
    print(f"\n{title}")
    print(f"çŸ©é™£å½¢ç‹€: {rows} x {cols}")
    print(f"é¡¯ç¤º: {display_rows} x {display_cols} (å®Œæ•´: {rows} x {cols})")
    print(f"æ•¸å€¼ç¯„åœ: [{matrix.min():.6f}, {matrix.max():.6f}]")
    print(f"å¹³å‡å€¼: {matrix.mean():.6f}")
    
    print("çŸ©é™£å…§å®¹:")
    print("â”Œ" + "â”€" * (display_cols * 12 + 1) + "â”")
    for i in range(display_rows):
        row_str = "â”‚"
        for j in range(display_cols):
            row_str += f" {matrix[i,j]:9.6f}"
        if display_cols < cols:
            row_str += " ..."
        row_str += " â”‚"
        print(row_str)
    
    if display_rows < rows:
        print("â”‚" + " ...".center(display_cols * 12 + 1) + "â”‚")
    
    print("â””" + "â”€" * (display_cols * 12 + 1) + "â”˜")

def test_single_image_with_full_matrices(model, testloader, image_index=0):
    """
    æ¸¬è©¦å–®å¼µåœ–ç‰‡ä¸¦é¡¯ç¤ºå®Œæ•´çš„çŸ©é™£è¼¸å‡º
    """
    # ç²å–æ¸¬è©¦é›†ä¸­çš„å–®å¼µåœ–ç‰‡
    model.eval()
    test_data = list(testloader)
    images, labels = test_data[0]
    
    # é¸æ“‡æŒ‡å®šç´¢å¼•çš„åœ–ç‰‡
    single_image = images[image_index:image_index+1]
    single_label = labels[image_index:image_index+1]
    
    print(f"\n{'='*100}")
    print(f"æ¸¬è©¦å–®å¼µåœ–ç‰‡ (ç´¢å¼•: {image_index}, çœŸå¯¦æ¨™ç±¤: {single_label.item()})")
    print(f"{'='*100}")
    
    with torch.no_grad():
        # 1. é¡¯ç¤ºåŸå§‹è¼¸å…¥åœ–ç‰‡
        print(f"\nğŸ“¥ 1. åŸå§‹è¼¸å…¥åœ–ç‰‡:")
        input_matrix = single_image.squeeze().cpu().numpy()
        print_full_matrix(input_matrix, "è¼¸å…¥åœ–ç‰‡çŸ©é™£ (28x28)")
        
        plt.figure(figsize=(15, 4))
        plt.subplot(1, 4, 1)
        plt.imshow(input_matrix, cmap='gray')
        plt.title(f'è¼¸å…¥åœ–ç‰‡\næ•¸å­—: {single_label.item()}')
        plt.axis('off')
        
        # 2. CONV1 è¼¸å‡º - é¡¯ç¤ºå¤šå€‹é€šé“çš„å®Œæ•´çŸ©é™£
        conv1_output = model.conv1(single_image)
        conv1_output_np = conv1_output.squeeze(0).cpu().numpy()  # [32, 28, 28]
        
        print(f"\nğŸ”„ 2. CONV1 å±¤è¼¸å‡º:")
        print(f"   è¼¸å‡ºå½¢ç‹€: {conv1_output.shape}")
        print(f"   æ•´é«”æ•¸å€¼ç¯„åœ: [{conv1_output.min():.6f}, {conv1_output.max():.6f}]")
        
        # é¡¯ç¤ºå‰3å€‹é€šé“çš„å®Œæ•´CONV1è¼¸å‡ºçŸ©é™£
        for channel in range(min(32, 32)):
            print_full_matrix(
                conv1_output_np[channel], 
                f"CONV1 è¼¸å‡º - é€šé“ {channel} å®Œæ•´çŸ©é™£ (28x28)",
                max_display_rows=28,
                max_display_cols=28
            )
        
        # å¯è¦–åŒ–CONV1è¼¸å‡º
        plt.subplot(1, 4, 2)
        best_channel = np.argmax(conv1_output_np.mean(axis=(1,2)))
        plt.imshow(conv1_output_np[best_channel], cmap='RdBu')
        plt.title(f'CONV1è¼¸å‡º (Ch{best_channel})\nç¯„åœ: [{conv1_output_np[best_channel].min():.3f}, {conv1_output_np[best_channel].max():.3f}]')
        plt.axis('off')
        plt.colorbar()
        
        # 3. ReLU æ¿€æ´»è¼¸å‡º - é¡¯ç¤ºå¤šå€‹é€šé“çš„å®Œæ•´çŸ©é™£
        relu_output = torch.relu(conv1_output)
        relu_output_np = relu_output.squeeze(0).cpu().numpy()  # [32, 28, 28]
        
        print(f"\nğŸ”¦ 3. ReLU æ¿€æ´»å¾Œè¼¸å‡º:")
        print(f"   è¼¸å‡ºå½¢ç‹€: {relu_output.shape}")
        print(f"   æ•´é«”æ•¸å€¼ç¯„åœ: [{relu_output.min():.6f}, {relu_output.max():.6f}]")
        print(f"   æ•´é«”é›¶å€¼æ¯”ä¾‹: {(relu_output == 0).float().mean():.4%}")
        
        # é¡¯ç¤º32å€‹é€šé“çš„å®Œæ•´ReLUè¼¸å‡ºçŸ©é™£
        for channel in range(min(32, 32)):
            zero_ratio = (relu_output_np[channel] == 0).mean()
            print_full_matrix(
                relu_output_np[channel], 
                f"ReLU è¼¸å‡º - é€šé“ {channel} å®Œæ•´çŸ©é™£ (28x28) - é›¶å€¼æ¯”ä¾‹: {zero_ratio:.4%}",
                max_display_rows=28,
                max_display_cols=28
            )
        
        # å¯è¦–åŒ–ReLUè¼¸å‡º
        plt.subplot(1, 4, 3)
        best_channel_relu = np.argmax(relu_output_np.mean(axis=(1,2)))
        zero_ratio = (relu_output_np[best_channel_relu] == 0).mean()
        plt.imshow(relu_output_np[best_channel_relu], cmap='hot')
        plt.title(f'ReLUå¾Œ (Ch{best_channel_relu})\né›¶å€¼æ¯”ä¾‹: {zero_ratio:.2%}')
        plt.axis('off')
        plt.colorbar()
        
        # 4. æ± åŒ–è¼¸å‡º
        pooled_output = torch.max_pool2d(relu_output, 2)
        pooled_output_np = pooled_output.squeeze(0).cpu().numpy()  # [32, 14, 14]
        
        print(f"\nğŸ“ 4. æ± åŒ–å¾Œè¼¸å‡º:")
        print(f"   è¼¸å‡ºå½¢ç‹€: {pooled_output.shape}")
        print(f"   æ•´é«”æ•¸å€¼ç¯„åœ: [{pooled_output.min():.6f}, {pooled_output.max():.6f}]")
        
        # é¡¯ç¤º32å€‹é€šé“çš„å®Œæ•´æ± åŒ–è¼¸å‡ºçŸ©é™£
        for channel in range(min(32, 32)):
            print_full_matrix(
                pooled_output_np[channel], 
                f"æ± åŒ–è¼¸å‡º - é€šé“ {channel} å®Œæ•´çŸ©é™£ (14x14)",
                max_display_rows=14,
                max_display_cols=14
            )
        
        # å¯è¦–åŒ–æ± åŒ–è¼¸å‡º
        plt.subplot(1, 4, 4)
        best_channel_pool = np.argmax(pooled_output_np.mean(axis=(1,2)))
        plt.imshow(pooled_output_np[best_channel_pool], cmap='hot')
        plt.title(f'æ± åŒ–å¾Œ (Ch{best_channel_pool})\nå°ºå¯¸: 14x14')
        plt.axis('off')
        plt.colorbar()
        
        plt.tight_layout()
        plt.show()
        
        # 5. æœ€çµ‚è¾¨è­˜çµæœ
        final_output = model(single_image)
        probabilities = torch.softmax(final_output, dim=1)
        predicted_class = torch.argmax(final_output, dim=1).item()
        confidence = probabilities[0, predicted_class].item()
        
        print(f"\nğŸ¯ 5. æœ€çµ‚è¾¨è­˜çµæœ:")
        print(f"   åŸå§‹è¼¸å‡º: {final_output.squeeze().cpu().numpy()}")
        print(f"   æ©Ÿç‡åˆ†ä½ˆ: {probabilities.squeeze().cpu().numpy()}")
        print(f"   é æ¸¬æ•¸å­—: {predicted_class}")
        print(f"   çœŸå¯¦æ•¸å­—: {single_label.item()}")
        print(f"   ç½®ä¿¡åº¦: {confidence:.6f}")
        print(f"   çµæœ: {'âœ… æ­£ç¢º' if predicted_class == single_label.item() else 'âŒ éŒ¯èª¤'}")
        
        # é¡¯ç¤ºæ©Ÿç‡åˆ†ä½ˆåœ–
        plt.figure(figsize=(12, 4))
        
        plt.subplot(1, 2, 1)
        x_pos = np.arange(10)
        probs = probabilities.squeeze().cpu().numpy()
        colors = ['red' if i == predicted_class else ('green' if i == single_label.item() else 'blue') 
                 for i in range(10)]
        
        bars = plt.bar(x_pos, probs, color=colors, alpha=0.7)
        plt.xlabel('æ•¸å­—')
        plt.ylabel('æ©Ÿç‡')
        plt.title('å„æ•¸å­—é æ¸¬æ©Ÿç‡\n(ç´…è‰²:é æ¸¬, ç¶ è‰²:çœŸå¯¦, è—è‰²:å…¶ä»–)')
        plt.xticks(x_pos)
        
        for bar, prob in zip(bars, probs):
            plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, 
                    f'{prob:.4f}', ha='center', va='bottom', fontsize=8)
        
        plt.subplot(1, 2, 2)
        # é¡¯ç¤ºæ‰€æœ‰é€šé“çš„æ¿€æ´»çµ±è¨ˆ
        channel_activations = relu_output.mean(dim=[0, 2, 3]).cpu().numpy()
        plt.bar(np.arange(len(channel_activations)), channel_activations, alpha=0.7)
        plt.xlabel('é€šé“ç´¢å¼•')
        plt.ylabel('å¹³å‡æ¿€æ´»å€¼')
        plt.title('æ‰€æœ‰32å€‹é€šé“çš„å¹³å‡æ¿€æ´»')
        plt.xticks(np.arange(0, 32, 2))
        
        plt.tight_layout()
        plt.show()
        
        return {
            'input_image': single_image,
            'conv1_output': conv1_output,
            'relu_output': relu_output,
            'pooled_output': pooled_output,
            'final_output': final_output,
            'predicted': predicted_class,
            'actual': single_label.item(),
            'confidence': confidence
        }

def save_full_matrices_to_file(results, image_index=0):
    """å°‡å®Œæ•´çŸ©é™£ä¿å­˜åˆ°æ–‡ä»¶"""
    conv1_output_np = results['conv1_output'].squeeze(0).cpu().numpy()
    relu_output_np = results['relu_output'].squeeze(0).cpu().numpy()
    pooled_output_np = results['pooled_output'].squeeze(0).cpu().numpy()
    
    filename = f"full_matrices_image_{image_index}.txt"
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"å®Œæ•´çŸ©é™£è¼¸å‡º - åœ–ç‰‡ç´¢å¼•: {image_index}\n")
        f.write(f"çœŸå¯¦æ¨™ç±¤: {results['actual']}, é æ¸¬æ¨™ç±¤: {results['predicted']}\n")
        f.write("="*100 + "\n\n")
        
        # ä¿å­˜CONV1è¼¸å‡º
        f.write("CONV1 è¼¸å‡ºçŸ©é™£ (32å€‹é€šé“, æ¯å€‹28x28):\n")
        f.write("="*80 + "\n")
        for channel in range(32):
            f.write(f"\né€šé“ {channel}:\n")
            f.write(f"ç¯„åœ: [{conv1_output_np[channel].min():.6f}, {conv1_output_np[channel].max():.6f}]\n")
            f.write(f"å¹³å‡å€¼: {conv1_output_np[channel].mean():.6f}\n")
            np.savetxt(f, conv1_output_np[channel], fmt='%10.6f')
            f.write("\n")
        
        # ä¿å­˜ReLUè¼¸å‡º
        f.write("\n\nReLU è¼¸å‡ºçŸ©é™£ (32å€‹é€šé“, æ¯å€‹28x28):\n")
        f.write("="*80 + "\n")
        for channel in range(32):
            zero_ratio = (relu_output_np[channel] == 0).mean()
            f.write(f"\né€šé“ {channel} (é›¶å€¼æ¯”ä¾‹: {zero_ratio:.4%}):\n")
            f.write(f"ç¯„åœ: [{relu_output_np[channel].min():.6f}, {relu_output_np[channel].max():.6f}]\n")
            f.write(f"å¹³å‡å€¼: {relu_output_np[channel].mean():.6f}\n")
            np.savetxt(f, relu_output_np[channel], fmt='%10.6f')
            f.write("\n")
        
        # ä¿å­˜æ± åŒ–è¼¸å‡º
        f.write("\n\næ± åŒ–è¼¸å‡ºçŸ©é™£ (32å€‹é€šé“, æ¯å€‹14x14):\n")
        f.write("="*80 + "\n")
        for channel in range(32):
            f.write(f"\né€šé“ {channel}:\n")
            f.write(f"ç¯„åœ: [{pooled_output_np[channel].min():.6f}, {pooled_output_np[channel].max():.6f}]\n")
            f.write(f"å¹³å‡å€¼: {pooled_output_np[channel].mean():.6f}\n")
            np.savetxt(f, pooled_output_np[channel], fmt='%10.6f')
            f.write("\n")
    
    print(f"\nğŸ’¾ å®Œæ•´çŸ©é™£å·²ä¿å­˜åˆ°æ–‡ä»¶: {filename}")

# ä¸»ç¨‹å¼
def main():
    # è¼‰å…¥æ¨¡å‹å’Œæ•¸æ“š
    #model = Net()
    transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,))])
    testset = torchvision.datasets.MNIST(root='./data', train=False, download=True, transform=transform)
    testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=False)
    
    print("é–‹å§‹æ¸¬è©¦å–®å¼µåœ–ç‰‡ä¸¦é¡¯ç¤ºå®Œæ•´çŸ©é™£...")
    
    # æ¸¬è©¦åœ–ç‰‡
    results = test_single_image_with_full_matrices(model, testloader, image_index=0)
    
    # ä¿å­˜å®Œæ•´çŸ©é™£åˆ°æ–‡ä»¶
    save_full_matrices_to_file(results, image_index=0)
    
    print(f"\n{'='*100}")
    print("æ¸¬è©¦å®Œæˆï¼")
    print(f"è¼¸å…¥åœ–ç‰‡: 28x28 çŸ©é™£")
    print(f"CONV1è¼¸å‡º: 32å€‹ 28x28 çŸ©é™£") 
    print(f"ReLUè¼¸å‡º: 32å€‹ 28x28 çŸ©é™£")
    print(f"æ± åŒ–è¼¸å‡º: 32å€‹ 14x14 çŸ©é™£")
    print(f"{'='*100}")

# åŸ·è¡Œ
if __name__ == "__main__":
    main()
